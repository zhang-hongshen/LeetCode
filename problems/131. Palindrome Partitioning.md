## [131. Palindrome Partitioning](https://leetcode.cn/problems/palindrome-partitioning/)

### First Solution
**Java**
```java
class Solution {
    class Solution {

    List<List<String>> res;
    List<String> path;

    public List<List<String>> partition(String s) {
        res = new ArrayList<>();
        path = new ArrayList<>();
        dfs(s, 0);
        return res;
    }

    private void dfs(String s, int fromIndex) {
        int n = s.length();
        if(fromIndex >= n) {
            res.add(new ArrayList<>(path));
            return;
        }
        for(int i = fromIndex + 1; i <= n; i += 1) {
            String sub = s.substring(fromIndex, i);
            if(!isPalindrome(sub)) {
                continue;
            }
            path.add(sub);
            dfs(s, i);
            path.remove(path.size() - 1);
        }
    }

    private boolean isPalindrome(String s) {
        int i = 0, j = s.length() - 1;
        while(i < j) {
            if(s.charAt(i) != s.charAt(j)) {
                return false;
            }
            i += 1;
            j -= 1;
        }
        return true;
    }
}
```

**Python**
```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        res, path = [], []
        n = len(s)

        def is_palindrome(s):
            i, j = 0, len(s) - 1
            while i < j:
                if s[i] != s[j]:
                    return False
                i += 1
                j -= 1
            return True

        def dfs(start):
            if start >= n:
                res.append(path[:])
                return
            for i in range(start + 1, n + 1):
                if not is_palindrome(s[start:i]):
                    continue
                path.append(s[start:i])
                dfs(i)
                path.pop()
        
        dfs(0)
        return res
```


### Second Solution
**Java**
```java
class Solution {
    public List<List<String>> partition(String s) {
        List<List<String>> res = new LinkedList<>();
        List<String> subRes = new LinkedList<>();
        int n = s.length();
        boolean[][] isPalindrome = new boolean[n][n];
        for(int i = n - 1; i >= 0; i -= 1) {
            isPalindrome[i][i] = true;
            if(i > 0) {
                isPalindrome[i][i - 1] = true;
            }
            for(int j = i + 1; j < n; j += 1) {
                isPalindrome[i][j] = s.charAt(i) == s.charAt(j) && isPalindrome[i + 1][j - 1];
            }
        }
        backtrack(s, 0, isPalindrome, res, subRes);
        return res;
    }

    private void backtrack(String s, int fromIndex, boolean[][] isPalindrome, List<List<String>> res, List<String> subRes) {
        int n = s.length();
        if(fromIndex == n) {
            res.add(new ArrayList<>(subRes));
            return;
        }
        for(int toIndex = fromIndex; toIndex < n; toIndex += 1) {
            if(!isPalindrome[fromIndex][toIndex]) {
                continue;
            }
            String subStr = s.substring(fromIndex, toIndex + 1);
            subRes.add(subStr);
            backtrack(s, toIndex + 1, isPalindrome, res, subRes);
            subRes.removeLast();
        }
    }

}
```

**Python**
```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        res, sub_res, n =  [], [], len(s)
        isPalindrome = [[True] * n for _ in range(n)]

        for i in range(n - 2, -1, -1):
            for j in range(i + 1, n):
                isPalindrome[i][j] = s[i] == s[j] and isPalindrome[i + 1][j - 1]

        def backtrack(from_index):
            if from_index == n:
                res.append(sub_res[:])
                return
            for end_index in range(from_index, n):
                if not isPalindrome[from_index][end_index]:
                    continue
                sub_str = s[from_index : end_index + 1]
                sub_res.append(sub_str)
                backtrack(end_index + 1)
                sub_res.pop()
        
        backtrack(0)
        return res

```