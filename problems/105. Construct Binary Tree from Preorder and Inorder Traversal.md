## [105. Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

### First Solution

**Java**
```java
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return buildTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);
    }

    private int IndexOf(int[] arr, int fromIndex, int toIndex, int target) {
        while(fromIndex <= toIndex) {
            if(arr[fromIndex] == target) {
                return fromIndex;
            } else if(arr[toIndex] == target) {
                return toIndex;
            }
            fromIndex += 1;
            toIndex -= 1;
        }
        return -1;
    }

    private TreeNode buildTree(int[] preorder, int preorderFromIndex, int preorderToIndex, 
    int[] inorder, int inorderFromIndex, int inorderToIndex) {
        if(preorderFromIndex > preorderToIndex || inorderFromIndex > inorderToIndex) {
            return null;
        }
        TreeNode root = new TreeNode(preorder[preorderFromIndex]);
        int rootIndex = IndexOf(inorder, inorderFromIndex, inorderToIndex, root.val);
        int leftTreeNodeNum = rootIndex - inorderFromIndex;
        root.left = buildTree(preorder, preorderFromIndex + 1, preorderFromIndex + leftTreeNodeNum, 
                                inorder, inorderFromIndex, rootIndex - 1);
        root.right = buildTree(preorder, preorderFromIndex + leftTreeNodeNum + 1, preorderToIndex, 
                                inorder, rootIndex + 1, inorderToIndex);
        return root;
    }
}
```
**Python**
```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        
        def __buildTree__(preorder_start, preorder_end, inorder_start, inorder_end):
            if preorder_start > preorder_end or inorder_start > inorder_end:
                return None
            root = TreeNode(preorder[preorder_start])

            def search():
                i, j = inorder_start, inorder_end
                while i <= j:
                    if inorder[i] == root.val:
                        return i
                    if inorder[j] == root.val:
                        return j
                    i += 1
                    j -= 1
                return -1
            
            root_index = search()
            left_num = root_index - inorder_start
            root.left = __buildTree__(preorder_start + 1, preorder_start + left_num, inorder_start, root_index - 1)
            root.right = __buildTree__(preorder_start + left_num + 1, preorder_end, root_index + 1, inorder_end)
            return root

        return __buildTree__(0, len(preorder) - 1, 0, len(inorder) - 1)
```
|time complexity|space complexity|
|:-------------:|:--------------:|
|$O(n)$         |$O(n)$          |