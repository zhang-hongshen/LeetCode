## [207. Course Schedule](https://leetcode.com/problems/course-schedule/)

### First Solution

**Java**

```java
class Solution {

    private enum State {
        NOT_STARTED,
        VISITING,
        COMPLETED
    }

    public boolean canFinish(int numCourses, int[][] prerequisites) {
        Map<Integer, List<Integer>> edges = new HashMap<>();
        for(int[] prerequisite : prerequisites) {
            int a = prerequisite[0], b = prerequisite[1];
            List<Integer> vertice = edges.getOrDefault(a, new ArrayList<Integer>());
            vertice.add(b);
            edges.put(a, vertice);
        }
        State[] state = new State[numCourses];
        Arrays.fill(state, State.NOT_STARTED);
        for(int i = 0; i < numCourses; i += 1) {
            if(state[i] != State.NOT_STARTED) {
                continue;
            }
            if(!dfs(i, state, edges)) {
                return false;
            }
        }
        return true;

    }

    private boolean dfs(int vertex, State[] state, Map<Integer, List<Integer>> edges) {
        if(state[vertex] == State.VISITING) {
            return false;
        }
        if(state[vertex] == State.COMPLETED) {
            return true;
        }
        state[vertex] = State.VISITING;
        if(edges.containsKey(vertex)) {
            for (int v : edges.get(vertex)) {
                if (!dfs(v, state, edges)) {
                    return false;
                }
            }
        }
        state[vertex] = State.COMPLETED;
        return true;
    }
}
```

｜time complexity｜space complexity|
|:-:|:-:|
|$O(n + m)$|$O(n + m)$|

### Second Solution

**Java**

```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        Map<Integer, List<Integer>> edges = new HashMap<>();
        int[] indegrees = new int[numCourses];

        for(int[] prerequisite : prerequisites) {
            int a = prerequisite[0], b = prerequisite[1];
            List<Integer> vertice = edges.getOrDefault(a, new ArrayList<Integer>());
            vertice.add(b);
            edges.put(a, vertice);
            indegrees[b] += 1;
        }

        Queue<Integer> q = new LinkedList<>();
        for (int i = 0; i < numCourses; i++) {
            if (indegrees[i] == 0) {
                q.add(i);
            }
        }

        int actualNumCourses = 0;
        while(!q.isEmpty()) {
            int u = q.poll();
            actualNumCourses += 1;
            if(edges.containsKey(u)) {
                for(int v : edges.get(u)) {
                    indegrees[v] -= 1;
                    if(indegrees[v] == 0) {
                        q.add(v);
                    }
                }
            }
        }
        return actualNumCourses == numCourses;
    }
}
```