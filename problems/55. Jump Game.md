## [55. Jump Game](https://leetcode.com/problems/jump-game/)

### First Solution
**Java**
```java
class Solution {
    public boolean canJump(int[] nums) {
        int n = nums.length;
        boolean[] dp = new boolean[n];
        dp[0] = true;
        for(int i = 0; i < n; i += 1) {
            if(!dp[i]) {
                return false;
            }
            int limit = Math.min(n, i + nums[i] + 1);
            for(int j = i; j < limit; j += 1) {
                dp[j] = true;
            }
        }
        return dp[n - 1];
    }
}
```

**Python**
```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        n = len(nums)
        dp = [False] * n
        dp[0] = True
        for i in range(n):
            if not dp[i]:
                return False
            limit = min(n, i + nums[i] + 1)
            for j in range(i, limit):
                dp[j] =  True
        return dp[n - 1]
```

### Second Solution
**Java**
```java
class Solution {
    public boolean canJump(int[] nums) {
        int n = nums.length;
        int farthest = 0;
        for(int i = 0; i < n; i += 1) {
            if(i > farthest) {
                return false;
            }
            farthest = Math.max(farthest, i + nums[i]);
            if(farthest >= n - 1) {
                return true;
            }
        }
        return true;
    }
}
```

**Python**
```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        farthest, last = 0, len(nums) - 1
        for i, num in enumerate(nums):
            if i > farthest:
                return False
            farthest = max(farthest, i + num)
            if farthest >= last:
                return True
        return True
```